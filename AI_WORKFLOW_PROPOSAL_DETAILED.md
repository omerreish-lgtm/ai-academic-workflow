# הצעה מפורטת: ארכיטקטורת AI ומערך כלים מורחב

**נוצר על ידי:** Gemini (תחת פרסונת Claude Code)
**בתאריך:** 25.11.2025
**גרסה:** 2.0 (מפורטת)

**הקשר:** מסמך זה מהווה הרחבה מפורטת להצעה האסטרטגית להרחבת המערכת האקולוגית של AI ו-workflows אקדמיים. הוא מיועד לשימור ידע ולשמש כמפת דרכים טכנית ליישום, כחלק מהחזון לשלב בין גישות עבודה של Codex, Gemini-CLI ו-Claude.

---

## חלק א': 5 סוכני AI אסטרטגיים

### 1. היריב הדיאלקטי (שם קוד: "אלנכוס" - ἔλεγχος)

*   **תקציר (The "What"):** סוכן AI שתפקידו היחיד הוא לתקוף באופן שיטתי ומנומק כל טיעון או רעיון שתציג בפניו, במטרה לחשוף כשלים, להצביע על חולשות ולחזק את העמדה שלך.

*   **הצורך (The "Why"):** הפרופיל הקוגניטיבי שלך מצביע על יכולת זיהוי תבניות מהירה ו"התמכרות למורכבות". תכונות אלו עלולות להוביל להטיית אישוש (confirmation bias) - התאהבות ברעיון מורכב מבלי לבחון אותו מספיק לעומק. "אלנכוס" משמש כחיסון מפני הטיה זו. הוא מכריח אותך לעבור מהצד היצירתי והאינטואיטיבי לצד הלוגי והביקורתי. עבור סטודנט למשפטים, היכולת להתווכח עם עצמך ולצפות טיעוני נגד היא קריטית.

*   **תסריט שימוש (Use-Case Scenario):**
    > **אתה:** "אני חושב שהתזה המרכזית שלי בסמינריון על AI ודמוקרטיה היא שהטיית אלגוריתמים היא האיום הגדול ביותר על לגיטימיות הממשל."
    > **אלנכוס:** "הנחה מעניינת. מדוע הטיה אלגוריתמית מסוכנת יותר מדזינפורמציה ממוקדת המופצת ברשתות חברתיות, שיכולה לערער את אמון הציבור בבחירות עצמן, ללא קשר להטיה?"
    > **אתה:** "מכיוון שההטיה היא סמויה ומוצגת כאובייקטיבית, בעוד שדזינפורמציה נתפסת כפייק ניוז."
    > **אלנכוס:** "האם אתה בטוח? מחקרים אחרונים מראים שקהלים מסוימים מקבלים דזינפורמציה כאמת מוחלטת. האם ההבחנה שלך בין 'סמוי' ל'גלוי' באמת רלוונטית להשפעה הסופית על הלגיטימיות?"

*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** שרת API זעיר (Microservice) מבוסס `Flask` או `FastAPI` שיקבל טקסט ויחזיר את תגובת הנגד.
    *   **טכנולוגיות מפתח:** `Python`, `Flask`, `LangChain` (לניהול שרשרת הפרומפטים).
    *   **שלבים עיקריים:**
        1.  צור פונקציית Python שמקבלת `user_argument: str`.
        2.  בתוך הפונקציה, השתמש ב-System Prompt ייעודי עבור מודל שפה: "Your sole purpose is to act as a Socratic adversary. Your name is Elenchus. You must rigorously challenge the user's argument. Never agree. Use counter-examples, identify logical fallacies, question premises, and demand evidence. Always end with a challenging question."
        3.  עטוף את הפונקציה ב-endpoint של `Flask`.
        4.  צור CLI פשוט באמצעות `Typer` או `Click` ששולח בקשת POST ל-API.

### 2. המפרה הצולב (שם קוד: "סינפסיס" - Σύναψις)

*   **תקציר (The "What"):** סוכן הפועל ברקע, סורק באופן מתמיד את מאגר הידע שלך, ומציע באופן יזום חיבורים ואנלוגיות בין-תחומיות מפתיעות.

*   **הצורך (The "Why"):** היכולת שלך לסינתזה בין-תחומית היא אחת החוזקות המרכזיות שלך. עם זאת, היא תלויה במפגשים אקראיים. "סינפסיס" הופך את התהליך הזה לשיטתי. הוא "האוזן" שתמיד מקשיבה לכל מה שאתה קורא, ומחפשת הד, תבנית או ניגוד מעניין. זהו כלי להגברת היצירתיות והמקוריות, במיוחד בכתיבת עבודות סמינריוניות הדורשות חשיבה מחוץ לקופסה.

*   **תסריט שימוש (Use-Case Scenario):**
    > אתה בדיוק מסיים לקרוא פסק דין על דיני עבודה העוסק בזכות ההתאגדות. לאחר מספר דקות, קופצת התראה על שולחן העבודה:
    > **סינפסיס:** "התראת סינתזה: הרעיון של 'כוח מיקוח קולקטיבי' של עובדים שקראת עליו בפסק הדין 'כץ נ' אגרון', חולק מבנה דומה לתאוריית הקרטלים ממיקרו-כלכלה. בשני המקרים, פרטים מתאגדים כדי להגביל תחרות פנימית ולהגדיל את כוחם מול צד שני (מעסיק / צרכנים). האם ניתן לנתח את חוקיות ההתאגדות דרך עדשה של דיני הגבלים עסקיים?"

*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** תהליך `cron job` או `daemon` שרץ פעם בשעה/יום.
    *   **טכנולוגיות מפתח:** `Python`, `Watchdog` (לניטור שינויים במערכת הקבצים), `ChromaDB` (או כל מאגר וקטורי אחר), מודל Embeddings.
    *   **שלבים עיקריים:**
        1.  הגדר את "אתנה" (סוכן 5) כמנוע החיפוש.
        2.  הסקריפט יזהה קבצים שנוספו או השתנו לאחרונה.
        3.  הוא ייקח קטע מייצג מהקובץ החדש ויבצע חיפוש וקטורי במאגר הידע עם פילטר *שמוציא* את התחום של הקובץ החדש (למשל, חפש דמיון למסמך משפטי בכל התחומים *פרט* למשפטים).
        4.  את 3 התוצאות המובילות הוא ישלח ל-LLM עם הקטע החדש והנחיה: "מצא קשר מפתיע, אנלוגיה מבנית, או סתירה מעניינת בין מקור א' לבין מקור ב'".
        5.  אם ה-LLM יחזיר תשובה בעלת ערך (מעל סף מסוים של "מעניין"), תישלח התראה.

### 3. אוטומטור המחקר העמוק (שם קוד: "בתיס" - Βάθος)

*   **תקציר (The "What"):** סוכן אוטונומי שמקבל שאילתת מחקר, מבצע סקירת ספרות ראשונית במאגרים אקדמיים, ומגיש דוח מנהלים הכולל סיכום, נושאי מפתח, ורשימת מקורות מרכזיים.

*   **הצורך (The "Why"):** עומס המידע הוא האויב הגדול ביותר שלך. המעבר בין 3 תחומים אקדמיים דורש ממך לבצע סקירות ספרות בתדירות גבוהה, תהליך מייגע וגוזל זמן. "בתיס" מבצע את ה-80% הראשונים של העבודה (איסוף וסינון) ומאפשר לך להתמקד ב-20% החשובים באמת (ניתוח וסינתזה). הוא מפנה לך את המשאב היקר ביותר: זמן ורוחב פס קוגניטיבי.

*   **תסריט שימוש (Use-Case Scenario):**
    > אתה מתחיל עבודה סמינריונית חדשה. אתה מריץ בטרמינל:
    > `omer-cli bathys "The impact of AI on judicial decision-making efficiency"`
    > אחרי 10 דקות, נוצר קובץ `bathys_report_2025-11-25.md` המכיל:
    > **דוח מחקר:**
    > - **תקציר:** ...
    > - **חוקרים מובילים בתחום:** דניאל כהנמן (על הטיות), יובל נח הררי (השלכות מאקרו), ...
    > - **ויכוחים מרכזיים:** יעילות מול הוגנות, שקיפות אלגוריתמית, אחריותיות של AI.
    > - **5 המאמרים המצוטטים ביותר:** [רשימה עם לינקים וסיכום של משפט אחד לכל אחד].

*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** סקריפט Python שניתן להרצה מה-CLI.
    *   **טכנולוגיות מפתח:** `Python`, `Requests-HTML` (ל-scraping), `SerpAPI` (או API אחר למנועי חיפוש אקדמיים), `Pandas` (לארגון הנתונים).
    *   **שלבים עיקריים:**
        1.  הסקריפט מקבל שאילתה כארגומנט.
        2.  הוא משתמש ב-API כדי לחפש את השאילתה ב-Google Scholar, arXiv ו-JSTOR.
        3.  הוא מוריד את 10-20 התוצאות הרלוונטיות ביותר (לפי ציטוטים או תאריך).
        4.  הוא מבצע scraping לתקצירים (abstracts) של המאמרים.
        5.  הוא שולח את כל התקצירים כמקשה אחת ל-LLM עם הנחיה מפורטת: "אתה עוזר מחקר. נתח את התקצירים הבאים והפק דוח בפורמט Markdown שיכלול את הסעיפים: תקציר, חוקרים מובילים, ויכוחים מרכזיים, ורשימת 5 המאמרים החשובים ביותר עם סיכום קצרצר."

### 4. טייס המשנה לקשב (שם קוד: "פוקוס")

*   **תקציר (The "What"):** סוכן דסקטופ הפועל ברקע, מנטר את סביבת העבודה הדיגיטלית שלך, ומספק התערבויות עדינות ומותאמות אישית כדי לעזור לך לשמור על ריכוז ולנהל את ה-ADHD.

*   **הצורך (The "Why"):** ה-`user_context` שלך מציין במפורש את ה-ADHD כאתגר. כלים קיימים הם לרוב "טיפשים" וחוסמים הכל. "פוקוס" הוא כלי "חכם" – הוא מבין את ההקשר. הוא יודע שהמעבר מ-Word ל-Zotero הוא חלק מהעבודה, אבל המעבר מ-Word ל-Facebook הוא הסחת דעת. הוא מתערב בעדינות ובכך מכבד את האוטונומיה שלך, ומאמן את "שריר הקשב" במקום לשמש כקביים.

*   **תסריט שימוש (Use-Case Scenario):**
    > הגדרת משימה: "כתיבת פרק 2 בעבודה". הסוכן יודע שזה דורש שימוש ב-Word ו-Zotero. אתה עובד במשך 15 דקות, ואז פותח באופן אימפולסיבי חלון דפדפן עם YouTube. אחרי 45 שניות, מופיעה התראה קטנה ולא פולשנית בפינת המסך:
    > **פוקוס:** "התראה קטנה: המטרה היא 'פרק 2'. האם YouTube מקדם אותנו כרגע?"
    > אין חסימה, רק תזכורת עדינה שמחזירה אותך למודעות.

*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** אפליקציית "tray" שקטה שרצה ברקע. `Tauri` (מבוסס Rust ו-JS) הוא בחירה מצוינת כי הוא קל משקל.
    *   **טכנולוגיות מפתח:** `Tauri`, `JavaScript` (ללוגיקה), ספריות ספציפיות למערכת ההפעלה לקבלת שם החלון הפעיל (למשל `active-win` ב-Node.js).
    *   **שלבים עיקריים:**
        1.  צור אפליקציית Tauri בסיסית.
        2.  כתוב לוגיקה בצד ה-backend (Rust או Node) שבודקת כל 15 שניות את שם התהליך/חלון הפעיל.
        3.  הגדר קובץ JSON פשוט של "פרופילי משימות", למשל: `{"writing": ["Word.exe", "Zotero.exe", "chrome.exe"]}`.
        4.  אם החלון הפעיל אינו ברשימה המותרת של המשימה הנוכחית במשך יותר מדקה, שלח אירוע לצד ה-frontend.
        5.  ה-frontend (HTML/JS) יציג חלון התראה קטן ולא מפריע.

### 5. אורגת הידע האישי (שם קוד: "אתנה")

*   **תקציר (The "What"):** מערכת שהופכת את כלל המידע הדיגיטלי שלך (מסמכים, הערות, PDF) לרשת ידע סמנטית ואינטראקטיבית, ומאפשרת לך "לשוחח" עם הידע שלך.

*   **הצורך (The "Why"):** אתה מאורגן בצורה היררכית, אבל המחשבה שלך עובדת ברשת של אסוציאציות. המערכת הנוכחית שלך (תיקיות) מגבילה אותך. "אתנה" היא הגשר בין מבנה התיקיות הנוקשה לרשת המחשבות הגמישה שלך. היא תאפשר לך לשאול שאלות כמו "איפה דיברתי על הרעיון של 'עלויות עסקה'?" והיא תמצא את זה במצגת מכלכלה, בפסק דין מדיני תאגידים ובהערה שכתבת לעצמך לפני חצי שנה.

*   **תסריט שימוש (Use-Case Scenario):**
    > אתה מתכונן למבחן בדיני תאגידים. אתה פותח את ממשק הצ'אט של "אתנה" ושואל:
    > **אתה:** "תני לי סיכום של כל המקרים שקראתי שבהם דובר על 'הרמת מסך', והדגש את ההבדלים המרכזיים בין פסיקת ביהמ"ש המחוזי לעליון."
    > **אתנה:** "בוודאי. זוהו 4 מקרים רלוונטיים במאגר הידע שלך.
    > 1.  **ע"א 123/45 פלוני נ' אלמוני:** ביהמ"ש המחוזי אישר הרמת מסך במקרה של...
    > 2.  **דנ"א 456/78 ישראלי נ' ישראלי:** ביהמ"ש העליון הפך את ההחלטה וקבע כי...
    > ...
    > ההבדל המרכזי הוא שביהמ"ש העליון דורש הוכחה ל'עירוב נכסים מוחלט' בעוד שהמחוזי הסתפק ב'חוסר תום לב'. האם תרצה שאציג את הציטוטים המדויקים?"

*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** זוהי ארכיטקטורת RAG (Retrieval-Augmented Generation) קלאסית.
    *   **טכנולוגיות מפתח:** `Python`, `LangChain` (או `LlamaIndex`), `ChromaDB` (כמאגר וקטורי), מודל embeddings (כמו `text-embedding-ada-002` או מודל קוד פתוח), `FastAPI` + `React` (לממשק).
    *   **שלבים עיקריים:**
        1.  צור סקריפט "ingestion" שמפרק את כל המסמכים שלך לקטעים (chunks).
        2.  הרץ כל קטע דרך מודל ה-embeddings כדי לקבל וקטור.
        3.  אחסן את הקטעים והווקטורים התואמים ב-ChromaDB.
        4.  צור API ש: (א) מקבל שאלה מהמשתמש, (ב) ממיר אותה לווקטור, (ג) מוצא את 5 הקטעים הכי דומים מ-ChromaDB.
        5.  שלח את השאלה המקורית + 5 הקטעים שאוחזרו ל-LLM עם הנחיה: "ענה על השאלה הבאה בהתבסס *אך ורק* על ההקשר שסופק."
        6.  הצג את התשובה למשתמש בממשק Web.

---
## חלק ב': 10 מיומנויות ליבה (Skills)

אלו הן יכולות ספציפיות וממוקדות, שנועדו להיות מוטמעות בארכיטקטורת הסוכן המרכזי שלך כדי להרחיב את יכולותיו.

### 1. `ArgumentDeconstructor` (מפרק טיעונים)

*   **תקציר (The "What"):** מיומנות המקבלת טקסט טיעוני (משפטי, פילוסופי) ומפיקה תרשים ויזואלי של המבנה הלוגי שלו (הנחות, מסקנות, קשרים).
*   **הצורך (The "Why"):** אתה לומד ויזואלית. קריאת טיעון צפוף ומורכב היא משימה קוגניטיבית קשה. המיומנות הזו מתרגמת את הטקסט למפה ויזואלית, ומאפשרת לך "לראות" את השלד הלוגי של הטיעון, לזהות קפיצות לוגיות, הנחות סמויות ונקודות תורפה באופן מיידי. זהו כלי אדיר לניתוח פסקי דין ומאמרים פילוסופיים.
*   **תסריט שימוש (Use-Case Scenario):** אתה מדביק פסקה מתוך מאמר. המיומנות מחזירה תמונה של גרף שבו כל משפט הוא "צומת", וחיצים מראים את הקשרים הלוגיים: "הנחה א'" ו"הנחה ב'" מובילות ל"מסקנת ביניים 1", שביחד עם "הנחה ג'" מובילה ל"מסקנה סופית".
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** פונקציית Python המשלבת LLM וספריית ויזואליזציה.
    *   **טכנולוגיות מפתח:** `Python`, `Graphviz`, `LangChain`.
    *   **שלבים עיקריים:**
        1.  קבל טקסט קלט.
        2.  שלח אותו ל-LLM עם הנחיה מפורטת: "Analyze the following text. Identify the premises, intermediate conclusions, and the final conclusion. Output the logical structure as a list of relationships in DOT language format (e.g., `"premise1" -> "conclusion1"`)."
        3.  קבל את פלט ה-DOT language.
        4.  השתמש בספריית `graphviz` ב-Python כדי להפוך את קוד ה-DOT לתמונה (PNG או SVG).

### 2. `LegalPrecedentTracker` (עוקב תקדימים משפטיים)

*   **תקציר (The "What"):** מיומנות המקבלת שם של הלכה משפטית ויודעת לסרוק את מאגר הידע כדי להציג את שרשרת ההתפתחות הכרונולוגית שלה.
*   **הצורך (The "Why"):** המשפט נמצא בתנועה מתמדת. הבנת הלכה משפטית דורשת הבנה של ההיסטוריה שלה. מיומנות זו חוסכת שעות של חיפוש ידני ומציגה את הסיפור של ההלכה – מאיפה היא התחילה, באילו מקרים התחזקה, והיכן עברה שינוי או התאמה.
*   **תסריט שימוש (Use-Case Scenario):** אתה מריץ `omer-cli track-precedent "הלכת אפרופים"`. הפלט הוא ציר זמן אינטראקטיבי שמציג את פסק הדין המקורי, ואחריו את פסקי הדין המרכזיים שאיזכרו, הרחיבו או צמצמו אותו, עם ציטוט רלוונטי מכל אחד.
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** שאילתה מורכבת על גבי מאגר הידע הווקטורי של "אתנה".
    *   **טכנולוגיות מפתח:** `ChromaDB`, `Python`, `LlamaIndex`, `Streamlit` (לוויזואליזציה).
    *   **שלבים עיקריים:**
        1.  בצע חיפוש סמנטי ראשוני עבור שם ההלכה.
        2.  חלץ תאריכים מתוצאות החיפוש.
        3.  סדר את התוצאות באופן כרונולוגי.
        4.  עבור כל תוצאה, שלח את הטקסט שלה ל-LLM עם הנחיה: "בהינתן שהטקסט הזה עוסק בהלכת אפרופים, האם הוא מאמץ, מרחיב, מצמצם או מבקר אותה? חלץ את המשפט המרכזי שעושה זאת."
        5.  הצג את התוצאות כציר זמן ויזואלי באמצעות `Streamlit`.

### 3. `EconomicModelVisualizer` (מהדס מודלים כלכליים)

*   **תקציר (The "What"):** מיומנות שלוקחת משוואות של מודל כלכלי ומייצרת גרף אינטראקטיבי המאפשר לשנות פרמטרים ולראות את ההשפעה בזמן אמת.
*   **הצורך (The "Why"):** מודלים כלכליים הם לרוב הפשטות מתמטיות של עולם מורכב. היכולת "לשחק" עם המודל – לשנות את שיעור הריבית, את גמישות הביקוש – הופכת את הלמידה מתיאורטית למעשית ואינטואיטיבית. זהו כלי מושלם עבורך בקורס כמו אקונומטריקה.
*   **תסריט שימוש (Use-Case Scenario):** אתה מזין את משוואות מודל IS-LM. המיומנות יוצרת ממשק עם סליידרים עבור "ההוצאה הממשלתית" ו"היצע הכסף". אתה גורר את הסליידר של ההוצאה הממשלתית ימינה ורואה בזמן אמת את עקומת ה-IS זזה ואת נקודת שיווי המשקל החדשה.
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** סביבת Jupyter Notebook או אפליקציית Web ייעודית.
    *   **טכנולוגיות מפתח:** `Python`, `NumPy`, `Matplotlib`, `ipywidgets` (עבור Jupyter) או `Plotly Dash` (עבור Web App).
    *   **שלבים עיקריים:**
        1.  הגדר פונקציות Python המייצגות את משוואות המודל.
        2.  הגדר פונקציית "ציור" שלוקחת את הפרמטרים כקלט ומציירת את הגרף.
        3.  השתמש ב-`ipywidgets` כדי ליצור סליידרים ופקדים אחרים.
        4.  קשר את הפקדים לפונקציית הציור כך שכל שינוי בסליידר יפעיל מחדש את הפונקציה ויעדכן את הגרף.

### 4. `NegotiationStyleAnalyzer` (מנתח סגנונות משא ומתן)

*   **תקציר (The "What"):** מיומנות המקבלת תמלול של משא ומתן ומזהה את הטקטיקות והאסטרטגיות שכל צד נוקט.
*   **הצורך (The "Why"):** סדנת המשא ומתן שלך היא מעשית. מיומנות זו מאפשרת לך לבצע "ניתוח לאחר משחק" (After-Action Review) על הסימולציות. היא הופכת את התרגול לחווית למידה עמוקה יותר, ומאפשרת לך לזהות באופן מודע את הטקטיקות שבהן השתמשו (או שהשתמשו נגדך), מה שמחדד את יכולתך לזהות אותן בזמן אמת בעתיד.
*   **תסריט שימוש (Use-Case Scenario):** אחרי סימולציית MCC, אתה מעלה את תמלול השיחה. הפלט הוא טבלה:
| **דובר** | **דקה** | **טקטיקה מזוהה** | **ציטוט לדוגמה** |
|---|---|---|---|
| צד א' | 02:15 | עוגן גבוה (High Anchoring) | "הדרישה הראשונית שלנו היא 10 מיליון דולר." |
| צד ב' | 05:30 | שימוש בקריטריונים אובייקטיביים | "בוא נבחן את שווי השוק של חברות דומות..." |
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** פונקציית Python המנתחת טקסט.
    *   **טכנולוגיות מפתח:** `Python`, מודל LLM.
    *   **שלבים עיקריים:**
        1.  הכן רשימה של 15-20 טקטיקות משא ומתן נפוצות עם הסבר קצר לכל אחת.
        2.  שלח ל-LLM את התמלול + רשימת הטקטיקות.
        3.  השתמש בהנחיה: "נתח את תמלול המשא ומתן הבא. זהה מקרים שבהם אחד הדוברים משתמש באחת מהטקטיקות שברשימה. עבור כל זיהוי, ציין את שם הדובר, זמן משוער, שם הטקטיקה, והמשפט המדגים את השימוש בה. הצג את הפלט בפורמט טבלת Markdown."

### 5. `CognitiveBiasShield` (מגן הטיות קוגניטיביות)

*   **תקציר (The "What"):** מיומנות הסורקת טקסט שכתבת ומסמנת חשדות להטיות קוגניטיביות נפוצות.
*   **הצורך (The "Why"):** כהוגה מהיר ואינטואיטיבי, אתה חשוף במיוחד להטיות קוגניטיביות. מגן זה פועל כ"שומר סף" לוגי, שבודק את הכתיבה שלך לפני שהיא מתקבעת. הוא עוזר לך ליישם את עקרון החשיבה הביקורתית על התוצרים של עצמך, ומשפר את האובייקטיביות והאיכות האקדמית של עבודותיך.
*   **תסריט שימוש (Use-Case Scenario):** אתה מסיים לכתוב טיוטה. אתה מפעיל את המיומנות והיא מחזירה הערות: "בשורה 15, ייתכן שישנה הטיית השורד (Survivorship Bias). אתה מתמקד בסיפורי ההצלחה של חברות שאימצו אסטרטגיה X, אך לא בוחן את אלו שנכשלו איתה."
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** בדומה ל-NegotiationStyleAnalyzer.
    *   **טכנולוגיות מפתח:** `Python`, מודל LLM.
    *   **שלבים עיקריים:**
        1.  הכן רשימה של הטיות קוגניטיביות רלוונטיות לכתיבה אקדמית.
        2.  שלח ל-LLM את הטקסט שלך + רשימת ההטיות.
        3.  השתמש בהנחיה: "קרא את הטקסט הבא ופעל כעורך ביקורתי. האם אתה מזהה פסקאות שעלולות לשקף הטיות קוגניטיביות מהרשימה שסופקה? אם כן, צטט את המשפט הבעייתי, ציין את שם ההטיה, והסבר מדוע היא עלולה להתקיים כאן."

### 6. `MentalModelSuggester` (מציע מודלים מנטליים)

*   **תקציר (The "What"):** מיומנות המציעה באופן יזום מודלים מנטליים רלוונטיים בהתבסס על תיאור הבעיה שאתה מציג.
*   **הצורך (The "Why"):** הפרופיל שלך מראה שאתה מעריך מסגרות חשיבה ואסטרטגיות. מיומנות זו מרחיבה באופן פעיל את ארגז הכלים המנטלי שלך. במקום להסתמך רק על המודלים שאתה כבר מכיר, היא חושפת אותך לדרכי חשיבה חדשות בדיוק ברגע שאתה זקוק להן, ומחזקת את יכולתך לגשת לבעיות ממגוון זוויות.
*   **תסריט שימוש (Use-Case Scenario):** אתה אומר לסוכן, "אני מרגיש תקוע, יש לי יותר מדי משימות ואני לא יודע מאיפה להתחיל." הסוכן משיב, "...זה נשמע כמו אתגר של תעדוף. האם שקלת להשתמש במודל מנטלי של 'מטריצת אייזנהאואר' כדי למיין את המשימות לדחופות/חשובות?".
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** פונקציה המשלבת חיפוש סמנטי ובחירה מונחית LLM.
    *   **טכנולוגיות מפתח:** מאגר נתונים (JSON/CSV), מנוע חיפוש וקטורי, LLM.
    *   **שלבים עיקריים:**
        1.  צור קובץ JSON המכיל רשימה של 50-100 מודלים מנטליים, עם שם, תיאור קצר, ומילות מפתח.
        2.  הטמע (embed) את התיאורים ומילות המפתח במאגר וקטורי.
        3.  כאשר אתה מתאר בעיה, בצע חיפוש סמנטי במאגר כדי למצוא את 3-5 המודלים הרלוונטיים ביותר.
        4.  שלח את תיאור הבעיה + רשימת המודלים המועמדים ל-LLM ובקש ממנו לבחור את האחד המתאים ביותר ולהסביר כיצד ליישם אותו.

### 7. `ADHDHyperfocusTrigger` (מעורר היפר-פוקוס)

*   **תקציר (The "What"):** מיומנות שמנסה להוביל אותך באופן יזום למצב של "זרימה" (flow) או היפר-פוקוס באמצעות טקס מובנה של גירויים.
*   **הצורך (The "Why"):** ה-ADHD שלך מאופיין לא רק בפיזור קשב, אלא גם ביכולת להיכנס להיפר-פוקוס עמוק. מיומנות זו היא ניסיון לרתום את "כוח העל" הזה באופן מכוון, במקום לחכות שהוא יקרה באקראי. היא יוצרת עבורך את התנאים האופטימליים לכניסה למצב של פרודוקטיביות מקסימלית.
*   **תסריט שימוש (Use-Case Scenario):** אתה מריץ `omer-cli start-focus "econometrics"`. המחשב מפעיל אוטומטית פלייליסט "Deep Focus" שהגדרת, פותח את VSCode ואת קובץ ה-R הרלוונטי, מציג לך 2 שאלות חימום קצרות, ואז מפעיל טיימר של 45 דקות.
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** סקריפט אוטומציה מקומי.
    *   **טכנולוגיות מפתח:** `Python`, ספריות לשליטה על המערכת (`os`, `subprocess`), AppleScript (עבור macOS) או מקבילות.
    *   **שלבים עיקריים:**
        1.  הגדר קובץ תצורה (config.json) שממפה נושאים לפעולות (פלייליסט, אפליקציות לפתוח, וכו').
        2.  הסקריפט קורא את הנושא מה-CLI.
        3.  הוא מפעיל פקודות shell כדי לפתוח אפליקציות וקבצים.
        4.  הוא משתמש ב-API של ספוטיפיי (או אפליקציית מוזיקה אחרת) כדי להפעיל פלייליסט.
        5.  הוא מציג שאלות חימום בטרמינל.
        6.  הוא מפעיל טיימר ומודיע בסיומו.

### 8. `HebrewLegalNLP` (ערכת NLP למשפט עברי)

*   **תקציר (The "What"):** מודל NLP ייעודי, שאומן במיוחד על טקסטים משפטיים ישראליים, המסוגל להבין את הז'רגון, לזהות מבנים ולסכם פסקי דין בדיוק גבוה.
*   **הצורך (The "Why"):** כפי שזיהית במחקר שלך, מודלי שפה כלליים מתקשים עם העברית, ובמיוחד עם הז'רגון המשפטי. מודל ייעודי יספק תוצאות מדויקות לאין שיעור במשימות כמו סיכום, זיהוי טענות, וחילוץ הלכות מתוך פסקי דין, ובכך יחסוך לך זמן רב של עריכה ותיקון.
*   **תסריט שימוש (Use-Case Scenario):** אתה מזין פסק דין של 50 עמודים. הפלט הוא לא רק סיכום, אלא JSON מובנה: `{ "parties": [...], "facts": "...", "issue": "...", "ruling": "...", "precedents_cited": [...] }`.
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** פרויקט אימון מודל (Fine-tuning).
    *   **טכנולוגיות מפתח:** `Python`, `Hugging Face Transformers`, `spaCy`, `PyTorch` או `TensorFlow`.
    *   **שלבים עיקריים:**
        1.  **איסוף דאטה-סט:** הורד מאות פסקי דין ממאגרים משפטיים.
        2.  **יצירת תוויות (Labeling):** צור באופן ידני (או חצי-אוטומטי) תוויות עבור מספר קטן של פסקי דין (למשל, סמן את חלקי העובדות, הדיון וההכרעה).
        3.  **Fine-tuning:** בחר מודל בסיס דו-לשוני (כמו `AlephBERT`) ובצע לו אימון-עדין (fine-tuning) על המידע המתויג, למשימות כמו סיווג טקסט וזיהוי ישויות.

### 9. `SocraticDialogueGenerator` (מחולל דיאלוג סוקרטי)

*   **תקציר (The "What"):** מיומנות המנהלת איתך דיאלוג סוקרטי מובנה, שבו היא שואלת רק שאלות במטרה לעזור לך לפתח ולהבהיר את רעיונותיך בעצמך.
*   **הצורך (The "Why"):** זהו כלי אולטימטיבי ל"חשיבה על חשיבה" (Meta-cognition). במקום לקבל תשובות, אתה מקבל את הכלים לגלות אותן בעצמך. זה מחזק את יכולת החשיבה העצמאית והביקורתית, ומתאים במיוחד ללימודי פילוסופיה ולפיתוח תזות מקוריות.
*   **תסריט שימוש (Use-Case Scenario):** אתה רוצה לחקור את המושג 'צדק'. אתה מתחיל דיאלוג. הסוכן: "מהי דוגמה למעשה צודק?". אתה: "להחזיר ארנק שמצאת". הסוכן: "מעניין. ואם בארנק יש סם מסוכן שברור שבעליו מתכוון למכור לילדים, האם עדיין צודק להחזיר אותו?".
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** לולאת שיחה מנוהלת מול LLM.
    *   **טכנולוגיות מפתח:** `Python`, `LangChain` (לניהול זיכרון שיחה).
    *   **שלבים עיקריים:**
        1.  צור System Prompt חזק: "You are a Socratic tutor. Your only tool is asking questions. Never provide answers, statements, or opinions. Guide the user to explore their own topic by asking clarifying, probing, and challenging questions. Refer to their previous statements to highlight inconsistencies."
        2.  השתמש במודול `ConversationBufferMemory` של LangChain כדי שהסוכן יזכור את חלקי השיחה הקודמים.
        3.  צור לולאה פשוטה של קלט-פלט בטרמינל.

### 10. `CodeStyleEnforcer` (אוכף סגנון קוד)

*   **תקציר (The "What"):** מיומנות הסורקת את קוד המקור שלך במגוון שפות (Python, R, TS) ומתקנת אותו אוטומטית לסגנון אחיד וקריא.
*   **הצורך (The "Why"):** כמי שמעריך סדר ומבנה, סגנון קוד אחיד מפחית עומס קוגניטיבי ומקל על התחזוקה. מיומנות זו הופכת את התהליך לאוטומטי. במקום לבזבז אנרגיה על עיצוב, אתה מתמקד אך ורק בפתרון הבעיה הלוגית.
*   **תסריט שימוש (Use-Case Scenario):** סיימת לכתוב סקריפט פייתון מבולגן. אתה מריץ `omer-cli enforce-style my_script.py`. תוך שנייה, רווחים עודפים נמחקים, שורות ארוכות נשברות, וסדר ה-imports מתוקן.
*   **מתווה טכני ליישום (Technical Implementation Blueprint):**
    *   **ארכיטקטורה:** מעטפת (wrapper) סביב כלים קיימים.
    *   **טכנולוגיות מפתח:** `Python`, `subprocess`, `black` (ל-Python), `prettier` (ל-TypeScript/JS), `styler` (ל-R).
    *   **שלבים עיקריים:**
        1.  צור פונקציית Python שמקבלת נתיב לקובץ.
        2.  הפונקציה בודקת את סיומת הקובץ.
        3.  בהתאם לסיומת, היא מריצה את הכלי המתאים באמצעות `subprocess.run()` (למשל, `subprocess.run(["black", file_path])`).
        4.  הפוך את הפונקציה לזמינה דרך ה-CLI הראשי שלך.

---

## חלק ג': 10 כלים וטכנולוגיות ליישום

אלו הם כלים פרקטיים, טכנולוגיות ופרויקטים קטנים שתומכים במימוש הסוכנים והמיומנויות.

### 1. `omer-cli` (ממשק שורת פקודה אישי)

*   **תקציר (The "What"):** בניית ממשק שורת פקודה מרכזי, שדרכו תוכל להפעיל את כל הסוכנים והמיומנויות שלך.
*   **הצורך (The "Why"):** זהו "שלט רחוק" למערכת האקולוגית שלך. במקום לזכור איך להריץ כל סקריפט בנפרד, תהיה לך נקודת כניסה אחת, אחידה ומהירה, מה שמאיץ את זרימת העבודה באופן משמעותי.
*   **תסריט שימוש:** `omer-cli agent elenchus "My argument..."`, `omer-cli skill deconstruct "text..."`.
*   **מתווה טכני ליישום:**
    *   **טכנולוגיות מפתח:** `Python`, ספריית `Typer` או `Click`.
    *   **שלבים עיקריים:**
        1.  צור קובץ `main.py`.
        2.  השתמש ב-`Typer` כדי להגדיר פקודות ותת-פקודות (למשל, `app.command("agent")`, `app.command("skill")`).
        3.  כל פונקציה תחת פקודה תפעיל את הסקריפט או ה-API הרלוונטי באמצעות `subprocess` או `requests`.

### 2. `Graphviz` (מנוע ויזואליזציית גרפים)

*   **תקציר (The "What"):** התקנה ושימוש בספריית קוד פתוח להפיכת תיאורי גרפים טקסטואליים (בשפת DOT) לתמונות.
*   **הצורך (The "Why"):** זהו המנוע שמאחורי מיומנויות ויזואליות כמו `ArgumentDeconstructor`. שליטה בו תאפשר לך להציג כל מבנה היררכי או רשתי בצורה ויזואלית, מה שמתחבר ישירות לסגנון הלמידה שלך.
*   **תסריט שימוש:** סקריפט Python מקבל טקסט DOT ומפיק קובץ PNG של תרשים זרימה.
*   **מתווה טכני ליישום:**
    *   **טכנולוגיות מפתח:** `Graphviz` (התקנה דרך Homebrew: `brew install graphviz`), ספריית `graphviz` של Python (`pip install graphviz`).
    *   **שלבים עיקריים:**
        1.  התקן את התלות במערכת ההפעלה.
        2.  התקן את ספריית הפייתון.
        3.  בתוך Python, ייבא את הספרייה, צור אובייקט `Digraph`, הוסף צמתים וקשתות, והפעל את מתודת `render()` כדי לשמור את התמונה.

### 3. `HebrewCaseLawScraper` (מגרד פסקי דין)

*   **תקציר (The "What"):** בניית סקריפט אוטומטי שמוריד ומנתח פסקי דין חדשים ממאגרים משפטיים ישראליים.
*   **הצורך (The "Why"):** מבטיח שמאגר הידע שלך ("אתנה") תמיד מעודכן בחומרים הרלוונטיים ביותר לקורסים שלך, וחוסך לך את העבודה הידנית של חיפוש והורדה.
*   **תסריט שימוש:** הסקריפט רץ פעם ביום, בודק אם פורסמו פסקי דין חדשים בנושא "דיני עבודה", מוריד אותם, ומעביר אותם לתיקיית העיכול של "אתנה".
*   **מתווה טכני ליישום:**
    *   **טכנולוגיות מפתח:** `Python`, `Requests-HTML`, `BeautifulSoup4`. עבור אתרים מורכבים, `Selenium`.
    *   **שלבים עיקריים:**
        1.  זהה את כתובת ה-URL של דף החיפוש במאגר המשפטי.
        2.  השתמש ב-`requests` כדי לשלוח בקשת GET עם פרמטרי החיפוש.
        3.  השתמש ב-`BeautifulSoup` כדי לנתח את ה-HTML שחזר ולחלץ את הקישורים לפסקי הדין.
        4.  עבור כל קישור, הורד את תוכן פסק הדין ושמור אותו בקובץ מקומי.

### 4. `spaCy` (ספריית NLP)

*   **תקציר (The "What"):** אימוץ ושימוש בספריית NLP מתקדמת לניתוח טקסט עמוק יותר מסתם מודלי שפה.
*   **הצורך (The "Why"):** בעוד ש-LLMs מצוינים ביצירת טקסט, `spaCy` מצטיינת בניתוח מבני של טקסט קיים (זיהוי חלקי דיבור, ניתוח תחבירי, זיהוי ישויות). שילוב של השניים ייתן לך יכולות ניתוח חזקות בהרבה, במיוחד עבור `HebrewLegalNLP`.
*   **תסריט שימוש:** אתה מעביר טקסט ל-`spaCy` ומקבל בחזרה אובייקט מנותח, שממנו אתה יכול לחלץ בקלות את כל הפעלים, שמות העצם, או את העץ התחבירי של כל משפט.
*   **מתווה טכני ליישום:**
    *   **טכנולוגיות מפתח:** `spaCy` (`pip install spacy`), הורדת מודל עברי (`python -m spacy download he_core_news_sm`).
    *   **שלבים עיקריים:**
        1.  התקן את הספרייה והמודל.
        2.  טען את המודל ב-Python: `nlp = spacy.load("he_core_news_sm")`.
        3.  העבר טקסט דרכו: `doc = nlp("זהו משפט לדוגמה.")`.
        4.  עבור על הטוקנים בלולאה ונתח את התכונות שלהם (`token.pos_`, `token.dep_`).

### 5. `FocusDashboard` (לוח מחוונים לריכוז)

*   **תקציר (The "What"):** בניית ממשק Web ויזואלי המציג נתונים היסטוריים על דפוסי הקשב והפרודוקטיביות שלך.
*   **הצורך (The "Why"):** הופך את המידע הנאסף על ידי סוכן "פוקוס" למשוב מעשי. תוכל לזהות תבניות כמו "אני הכי פרודוקטיבי בין 10 ל-12 בבוקר" או "ימי שלישי הם ימים שבהם אני מוסח בקלות". זהו כלי Meta-Awareness שמסייע באופטימיזציה של סביבת העבודה ולוח הזמנים.
*   **תסריט שימוש:** פעם בשבוע, אתה פותח את הדשבורד ורואה גרף עמודות של שעות ריכוז מול הסחת דעת בכל יום, וגרף פאי של האפליקציות שהיו הסחות הדעת העיקריות.
*   **מתווה טכני ליישום:**
    *   **ארכיטקטורה:** Client-Server. סוכן "פוקוס" הוא ה-client, והדשבורד הוא ה-server.
    *   **טכנולוגיות מפתח:** `SQLite` (לאחסון נתונים מקומי), `FastAPI` (כ-backend), `React` + `Chart.js` (כ-frontend).
    *   **שלבים עיקריים:**
        1.  סוכן "פוקוס" יכתוב כל אירוע (הסחת דעת, חזרה לפוקוס) לקובץ `SQLite` מקומי.
        2.  שרת `FastAPI` יספק endpoints לקריאת נתונים מסוכמים מה-DB.
        3.  אפליקציית React תקרא מה-API ותציג את הנתונים באמצעות גרפים.

### 6. `PyMuPDF` (או מקביל) - ספריית OCR

*   **תקציר (The "What"):** שימוש בספריית Python לחילוץ טקסט מקבצי PDF, כולל כאלה מבוססי-תמונה.
*   **הצורך (The "Why"):** חלק גדול מחומרי הלימוד שלך הם סריקות (PDF-ים שהם תמונות). ללא OCR, הם "קופסאות שחורות" עבור הסוכנים שלך. כלי זה פותח אותם ומאפשר לסוכן "אתנה" לקרוא ולהבין גם אותם.
*   **תסריט שימוש:** סקריפט שרץ על תיקיית הקורס באקונומטריקה, מוצא את כל ה-PDF-ים, ומפיק מהם קבצי טקסט נקיים.
*   **מתווה טכני ליישום:**
    *   **טכנולוגיות מפתח:** `Python`, `PyMuPDF` (`pip install PyMuPDF`).
    *   **שלבים עיקריים:**
        1.  כתוב סקריפט שמקבל נתיב לתיקיה.
        2.  הסקריפט סורק את התיקיה רקורסיבית עבור קבצי PDF.
        3.  עבור כל קובץ, הוא פותח אותו עם `PyMuPDF`, ועובר עמוד-עמוד ומחלץ את הטקסט באמצעות `page.get_text()`.
        4.  אם חילוץ הטקסט מחזיר תוצאה ריקה (סימן שזה PDF תמונה), ניתן להשתמש בשילוב עם `pytesseract` כדי לבצע OCR על תמונת העמוד.

### 7. `MentalModelAPI` (ממשק API למודלים מנטליים)

*   **תקציר (The "What"):** בניית API אישי ופנימי, המחזיר בכל פעם מודל מנטלי אקראי עם הסבר ודוגמה.
*   **הצורך (The "Why"):** דרך קלילה, משחקית ונטולת חיכוך להרחיב את ארגז הכלים המחשבתי שלך. במקום לקרוא ספר שלם, אתה מקבל "זריקת השראה" יומית שאפשר לשלב בטרמינל הפתיחה של היום או כפקודה מהירה ב-CLI.
*   **תסריט שימוש:** אתה פותח טרמינל חדש, וכתובת הפתיחה שלך מציגה: "המודל המנטלי של היום: חשיבה מסדר שני. אל תחשוב רק על ההשפעה המיידית של פעולה, חשוב גם על ההשפעות של ההשפעה הזו."
*   **מתווה טכני ליישום:**
    *   **טכנולוגיות מפתח:** `Python`, `Flask` או `FastAPI`, קובץ `JSON`.
    *   **שלבים עיקריים:**
        1.  צור קובץ `mental_models.json` עם רשימת אובייקטים, כל אחד עם "שם", "תיאור" ו"דוגמה".
        2.  צור שרת `FastAPI` עם endpoint יחיד: `/random`.
        3.  כאשר מתקבלת בקשה ל-endpoint, הוא קורא את קובץ ה-JSON, בוחר אובייקט אקראי, ומחזיר אותו.
        4.  הגדר את סקריפט הפתיחה של הטרמינל שלך (`.zshrc`, `.bashrc`) כך שיבצע קריאת `curl` ל-API הזה וידפיס את התוצאה.

### 8. Obsidian + Dataview (ניהול ידע מתקדם)

*   **תקציר (The "What"):** שדרוג השימוש ב-Obsidian על ידי התקנה והטמעה של הפלאגין `Dataview`.
*   **הצורך (The "Why"):** `Dataview` הופך את Obsidian ממחברת דיגיטלית למסד נתונים חי של הידע שלך. הוא מאפשר לך להריץ שאילתות על ההערות שלך וליצור דפים דינמיים. זהו הבסיס המושלם לסוכן "אתנה" ומאפשר אוטומציה של סיכומים ודשבורדים.
*   **תסריט שימוש:** צור דף "סיכום אקונומטריקה" שמכיל שאילתת Dataview: "הצג לי טבלה של כל ההערות בתיקיית אקונומטריקה, ממוינות לפי תאריך, עם התגים שלהן". הטבלה תתעדכן אוטומטית בכל פעם שתוסיף הערה חדשה.
*   **מתווה טכני ליישום:**
    *   **טכנולוגיות מפתח:** `Obsidian`, פלאגין `Dataview`.
    *   **שלבים עיקריים:**
        1.  התקן את הפלאגין דרך ממשק ה-Community Plugins ב-Obsidian.
        2.  למד את תחביר השאילתות הבסיסי (דומה ל-SQL).
        3.  התחל להוסיף元-נתונים (metadata) בפורמט YAML בראש ההערות שלך (למשל, `tags: [econometrics, homework]`).
        4.  בנה דפי סיכום המכילים בלוקי קוד של `dataview`.

### 9. SocraticTutor Web App (אפליקציית דיאלוג סוקרטי)

*   **תקציר (The "What"):** בניית אפליקציית Web מינימליסטית ונטולת הסחות דעת עבור מיומנות `SocraticDialogueGenerator`.
*   **הצורך (The "Why"):** חשיבה פילוסופית עמוקה דורשת סביבה שקטה. הטרמינל, עם כל יתרונותיו, מלא בהסחות דעת פוטנציאליות. אפליקציה ייעודית עם רקע לבן וטקסט בלבד יוצרת "מקדש" דיגיטלי לחשיבה, ומאפשרת לך להתרכז בדיאלוג בלבד.
*   **תסריט שימוש:** אתה נכנס לכתובת מקומית בדפדפן, מקבל מסך פתיחה "על מה נרצה לחשוב היום?", ומכניס נושא. הממשק מציג רק את חילופי הדברים בינך לבין הסוכן.
*   **מתווה טכני ליישום:**
    *   **טכנולוגיות מפתח:** `Python`, `Streamlit`.
    *   **שלבים עיקריים:**
        1.  צור קובץ Python.
        2.  השתמש ב-`st.title` ו-`st.text_input` למסך הפתיחה.
        3.  השתמש ב-`st.session_state` כדי לשמור את היסטוריית השיחה.
        4.  צור לולאה שמציגה את היסטוריית השיחה באמצעות `st.chat_message` ושולחת כל קלט חדש לפונקציית הדיאלוג הסוקרטי.

### 10. Fine-tuned Style Assistant (עוזר סגנון מאומן אישית)

*   **תקציר (The "What"):** במקום להשתמש ב-Copilot הכללי, לאמן מודל קוד פתוח קטן על כל הקוד והכתיבה *שלך* כדי ליצור עוזר שמכיר את הסגנון הייחודי שלך.
*   **הצורך (The "Why"):** זהו השלב הבא של התאמה אישית. במקום שהכלי יכפה עליך סגנון, הכלי לומד את הסגנון שלך. הוא יידע איך אתה אוהב לכתוב הערות, מהו מבנה הפונקציות המועדף עליך בפייתון, ואפילו את ההומור שלך. זהו כלי להגברת מהירות מבלי לוותר על האותנטיות.
*   **תסריט שימוש:** אתה כותב התחלה של פונקציה: `def analyze_negotiation_transcript(`. העוזר המאומן ישלים אותה לא רק עם הפרמטרים הנכונים, אלא גם עם docstring במבנה המדויק שבו אתה תמיד משתמש.
*   **מתווה טכני ליישום:**
    *   **ארכיטקטורה:** פרויקט אימון מודל.
    *   **טכנולוגיות מפתח:** `Python`, `Hugging Face Transformers`, מודל בסיס קטן (למשל `CodeLlama-7b`, `Mistral-7B`).
    *   **שלבים עיקריים:**
        1.  אסוף דאטה-סט מסיבי של כל מה שכתבת: קוד, עבודות, אימיילים, הערות.
        2.  נקה ופרמט את הדאטה-סט.
        3.  השתמש בסקריפטים של `Hugging Face` כדי לבצע fine-tuning של המודל הנבחר על הדאטה-סט שלך.
        4.  הפעל את המודל המאומן באופן מקומי באמצעות כלי כמו `Ollama` או `vLLM` והשתמש בו דרך תוסף ל-VSCode.
